{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport { Editor, Path, Text, Transforms } from 'slate';\nexport var getActiveList = function (editor, allListTypes) {\n  var _a = __read(Editor.nodes(editor, {\n    match: function (elem) {\n      return allListTypes.includes(elem.type);\n    },\n    mode: 'lowest'\n  }), 1),\n      matchingNode = _a[0];\n\n  return matchingNode;\n};\nexport var getActiveListType = function (editor, allListTypes) {\n  var _a, _b;\n\n  return (_b = (_a = getActiveList(editor, allListTypes)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.type;\n};\nexport var getPreviousListItem = function (editor, listItemType) {\n  var _a = __read(Editor.nodes(editor, {\n    match: function (elem) {\n      return elem.type === listItemType;\n    },\n    mode: 'lowest'\n  }), 1),\n      currentLi = _a[0];\n\n  var hasPrevious = currentLi && currentLi[1][currentLi[1].length - 1] > 0;\n  return hasPrevious ? Editor.node(editor, Path.previous(currentLi[1])) : null;\n};\nexport var increaseListIndention = function (editor, def, listType) {\n  var currentActiveType = getActiveListType(editor, def.allListTypes);\n  var previous = getPreviousListItem(editor, def.listItemType);\n  Transforms.setNodes(editor, {\n    type: def.listItemType\n  });\n\n  if (previous) {\n    // first make the previous node a paragraph\n    Transforms.setNodes(editor, {\n      type: null\n    }, {\n      at: previous[1]\n    }); // wrap the pararaph as a new list item\n\n    Transforms.wrapNodes(editor, {\n      type: def.listItemType,\n      children: []\n    }, {\n      at: previous[1]\n    }); // move the current node after the paragraph\n\n    Transforms.moveNodes(editor, {\n      to: __spread(previous[1], [1])\n    });\n    Transforms.wrapNodes(editor, {\n      type: listType !== null && listType !== void 0 ? listType : currentActiveType,\n      children: []\n    });\n  } else {\n    Transforms.wrapNodes(editor, {\n      type: listType !== null && listType !== void 0 ? listType : currentActiveType,\n      children: []\n    });\n  }\n};\n\nvar moveToParent = function (editor, nodePath, targetPath, parentIsList) {\n  var _a, _b;\n\n  Transforms.moveNodes(editor, {\n    at: nodePath,\n    to: targetPath\n  });\n\n  if (!parentIsList) {\n    var targetNode = Editor.node(editor, targetPath);\n    var onlyTextChildren = (_b = (_a = targetNode) === null || _a === void 0 ? void 0 : _a[0].children) === null || _b === void 0 ? void 0 : _b.every(function (child) {\n      return Text.isText(child) || Editor.isInline(editor, child);\n    });\n\n    if (onlyTextChildren) {\n      Transforms.setNodes(editor, {\n        type: null\n      }, {\n        at: targetPath\n      });\n    } else {\n      Transforms.unwrapNodes(editor, {\n        at: targetPath\n      });\n    }\n  }\n};\n\nexport var decreaseListIndention = function (editor, def) {\n  var _a, _b;\n\n  var _c = __read(Editor.nodes(editor, {\n    match: function (elem) {\n      return elem.type === def.listItemType;\n    },\n    mode: 'lowest'\n  }), 1),\n      currentLi = _c[0];\n\n  var currentLiPath = currentLi[1];\n  var currentParent = Path.parent(currentLiPath);\n  var parentListItemPath = Path.parent(currentParent);\n  var parentListItem = Editor.node(editor, parentListItemPath);\n  var parentIsList = ((_a = parentListItem) === null || _a === void 0 ? void 0 : _a[0].type) === def.listItemType;\n  var isFirstInItsList = currentLiPath[currentLiPath.length - 1] === 0;\n  var targetPath = parentIsList ? Path.next(parentListItemPath) : Path.next(currentParent);\n  var next;\n\n  do {\n    next = Editor.next(editor, {\n      at: currentLiPath\n    });\n\n    if (next) {\n      moveToParent(editor, next[1], targetPath, parentIsList);\n    }\n  } while (next);\n\n  moveToParent(editor, currentLiPath, targetPath, parentIsList);\n\n  if (isFirstInItsList) {\n    // the list will be empty now, remove it\n    Transforms.removeNodes(editor, {\n      at: currentParent\n    });\n\n    if (parentIsList) {\n      var previousParagraphPath = __spread(Path.previous(targetPath), [0]);\n\n      var previousParagraph = Editor.node(editor, previousParagraphPath);\n\n      if (!((_b = previousParagraph) === null || _b === void 0 ? void 0 : _b[0].type)) {\n        Transforms.unwrapNodes(editor, {\n          at: previousParagraphPath,\n          split: true\n        });\n      }\n    }\n  }\n};","map":{"version":3,"sources":["../../../src/pluginFactories/utils/listUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { Editor, Path, Text, Transforms } from 'slate';\nexport var getActiveList = function (editor, allListTypes) {\n    var _a = __read(Editor.nodes(editor, {\n        match: function (elem) { return allListTypes.includes(elem.type); },\n        mode: 'lowest',\n    }), 1), matchingNode = _a[0];\n    return matchingNode;\n};\nexport var getActiveListType = function (editor, allListTypes) {\n    var _a, _b;\n    return (_b = (_a = getActiveList(editor, allListTypes)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.type;\n};\nexport var getPreviousListItem = function (editor, listItemType) {\n    var _a = __read(Editor.nodes(editor, {\n        match: function (elem) { return elem.type === listItemType; },\n        mode: 'lowest',\n    }), 1), currentLi = _a[0];\n    var hasPrevious = currentLi && currentLi[1][currentLi[1].length - 1] > 0;\n    return hasPrevious ? Editor.node(editor, Path.previous(currentLi[1])) : null;\n};\nexport var increaseListIndention = function (editor, def, listType) {\n    var currentActiveType = getActiveListType(editor, def.allListTypes);\n    var previous = getPreviousListItem(editor, def.listItemType);\n    Transforms.setNodes(editor, {\n        type: def.listItemType,\n    });\n    if (previous) {\n        // first make the previous node a paragraph\n        Transforms.setNodes(editor, {\n            type: null,\n        }, {\n            at: previous[1],\n        });\n        // wrap the pararaph as a new list item\n        Transforms.wrapNodes(editor, {\n            type: def.listItemType,\n            children: [],\n        }, {\n            at: previous[1],\n        });\n        // move the current node after the paragraph\n        Transforms.moveNodes(editor, {\n            to: __spread(previous[1], [1]),\n        });\n        Transforms.wrapNodes(editor, {\n            type: (listType !== null && listType !== void 0 ? listType : currentActiveType),\n            children: [],\n        });\n    }\n    else {\n        Transforms.wrapNodes(editor, {\n            type: (listType !== null && listType !== void 0 ? listType : currentActiveType),\n            children: [],\n        });\n    }\n};\nvar moveToParent = function (editor, nodePath, targetPath, parentIsList) {\n    var _a, _b;\n    Transforms.moveNodes(editor, {\n        at: nodePath,\n        to: targetPath,\n    });\n    if (!parentIsList) {\n        var targetNode = Editor.node(editor, targetPath);\n        var onlyTextChildren = (_b = (_a = targetNode) === null || _a === void 0 ? void 0 : _a[0].children) === null || _b === void 0 ? void 0 : _b.every(function (child) { return Text.isText(child) || Editor.isInline(editor, child); });\n        if (onlyTextChildren) {\n            Transforms.setNodes(editor, {\n                type: null,\n            }, {\n                at: targetPath,\n            });\n        }\n        else {\n            Transforms.unwrapNodes(editor, {\n                at: targetPath,\n            });\n        }\n    }\n};\nexport var decreaseListIndention = function (editor, def) {\n    var _a, _b;\n    var _c = __read(Editor.nodes(editor, {\n        match: function (elem) { return elem.type === def.listItemType; },\n        mode: 'lowest',\n    }), 1), currentLi = _c[0];\n    var currentLiPath = currentLi[1];\n    var currentParent = Path.parent(currentLiPath);\n    var parentListItemPath = Path.parent(currentParent);\n    var parentListItem = Editor.node(editor, parentListItemPath);\n    var parentIsList = ((_a = parentListItem) === null || _a === void 0 ? void 0 : _a[0].type) === def.listItemType;\n    var isFirstInItsList = currentLiPath[currentLiPath.length - 1] === 0;\n    var targetPath = parentIsList\n        ? Path.next(parentListItemPath)\n        : Path.next(currentParent);\n    var next;\n    do {\n        next = Editor.next(editor, {\n            at: currentLiPath,\n        });\n        if (next) {\n            moveToParent(editor, next[1], targetPath, parentIsList);\n        }\n    } while (next);\n    moveToParent(editor, currentLiPath, targetPath, parentIsList);\n    if (isFirstInItsList) {\n        // the list will be empty now, remove it\n        Transforms.removeNodes(editor, {\n            at: currentParent,\n        });\n        if (parentIsList) {\n            var previousParagraphPath = __spread(Path.previous(targetPath), [0]);\n            var previousParagraph = Editor.node(editor, previousParagraphPath);\n            if (!((_b = previousParagraph) === null || _b === void 0 ? void 0 : _b[0].type)) {\n                Transforms.unwrapNodes(editor, {\n                    at: previousParagraphPath,\n                    split: true,\n                });\n            }\n        }\n    }\n};\n//# sourceMappingURL=listUtils.js.map"]},"metadata":{},"sourceType":"module"}