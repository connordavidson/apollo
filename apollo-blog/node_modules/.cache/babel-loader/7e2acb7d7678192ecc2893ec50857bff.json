{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport flattenDeep from './flattenDeep';\n/**\n * FIXME: transformInitialSlateState does some polymorphic type magic, so that it is directly\n * compatible with the shipped default plugins or plugins created with pluginFactories\n *\n * This is a bit ugly and might be hard to understand,\n * but on the other hand its easy to use for developers that use this library\n *\n * Basicaly what we do is to unpack the factory or its result until we find\n * - object: \"block\" | \"inline\" | \"mark\"\n * - type: \"SOMESTRING\"\n *\n * We might revisit this in the future.\n *\n */\n\nvar transformChildren = function (defNodes) {\n  return defNodes.map(function (defNode) {\n    var _a;\n\n    if (defNode.plugin) {\n      var defPluginNode = defNode; // tslint:disable-next-line:no-any\n\n      var slatePluginOrList = defPluginNode.plugin.toPlugin ? // tslint:disable-next-line:no-any\n      defPluginNode.plugin.toPlugin() : defPluginNode.plugin; // the result of plugin.toPlugin might be an array, e.g. the list plugin is an array, because it defines ul, li AND indention-options on the same plugin\n\n      var firstComponentPlugin = flattenDeep(slatePluginOrList).find(function (plugin) {\n        return plugin.pluginType === 'component' || plugin;\n      });\n\n      if (firstComponentPlugin && firstComponentPlugin.pluginType === 'component') {\n        return __assign(__assign({\n          type: firstComponentPlugin.type\n        }, (_a = defPluginNode.data, _a !== null && _a !== void 0 ? _a : {})), {\n          children: defPluginNode.children ? transformChildren(defPluginNode.children) : []\n        });\n      } else {\n        return null;\n      }\n    } else if (typeof defNode === 'string') {\n      return {\n        text: defNode\n      };\n    }\n  });\n};\n\nexport default (function (def) {\n  return {\n    slate: transformChildren(def.children)\n  };\n});","map":{"version":3,"sources":["../../src/utils/transformInitialSlateState.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAOA,OAAO,WAAP,MAAwB,eAAxB;AAEA;;;;;;;;;;;;;;;AAeA,IAAM,iBAAiB,GAAG,UAAC,QAAD,EAAyB;AACjD,SAAA,QAAQ,CAAC,GAAT,CAAa,UAAA,OAAA,EAAO;;;AAClB,QAAK,OAA2B,CAAC,MAAjC,EAAyC;AACvC,UAAM,aAAa,GAAoB,OAAvC,CADuC,CAEvC;;AACA,UAAM,iBAAiB,GAAI,aAAa,CAAC,MAAd,CAA6B,QAA7B,GACvB;AACC,MAAA,aAAa,CAAC,MAAd,CAA6B,QAA7B,EAFsB,GAGvB,aAAa,CAAC,MAHlB,CAHuC,CAQvC;;AACA,UAAM,oBAAoB,GAAG,WAAW,CACtC,iBADsC,CAAX,CAE3B,IAF2B,CAEtB,UAAA,MAAA,EAAM;AAAI,eAAA,MAAM,CAAC,UAAP,KAAsB,WAAtB,IAAA,MAAA;AAA2C,OAF/B,CAA7B;;AAGA,UACE,oBAAoB,IACpB,oBAAoB,CAAC,UAArB,KAAoC,WAFtC,EAGE;AACA,eAAA,QAAA,CAAA,QAAA,CAAA;AACE,UAAA,IAAI,EAAE,oBAAoB,CAAC;AAD7B,SAAA,GAEK,EAAA,GAAC,aAAa,CAAC,IAAf,EAAmB,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAF5B,EAAA,EAE+B;AAC7B,UAAA,QAAQ,EAAE,aAAa,CAAC,QAAd,GACN,iBAAiB,CAAC,aAAa,CAAC,QAAf,CADX,GAEN;AAHyB,SAF/B,CAAA;AAOD,OAXD,MAWO;AACL,eAAO,IAAP;AACD;AACF,KA1BD,MA0BO,IAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AACtC,aAAO;AACL,QAAA,IAAI,EAAE;AADD,OAAP;AAGD;AACF,GAhCD,CAAA;AAgCE,CAjCJ;;AAmCA,gBAAe,UAAC,GAAD,EAA0B;AAAK,SAAC;AAC7C,IAAA,KAAK,EAAE,iBAAiB,CAAC,GAAG,CAAC,QAAL;AADqB,GAAD;AAE5C,CAFF","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport flattenDeep from './flattenDeep';\n/**\n * FIXME: transformInitialSlateState does some polymorphic type magic, so that it is directly\n * compatible with the shipped default plugins or plugins created with pluginFactories\n *\n * This is a bit ugly and might be hard to understand,\n * but on the other hand its easy to use for developers that use this library\n *\n * Basicaly what we do is to unpack the factory or its result until we find\n * - object: \"block\" | \"inline\" | \"mark\"\n * - type: \"SOMESTRING\"\n *\n * We might revisit this in the future.\n *\n */\nvar transformChildren = function (defNodes) {\n    return defNodes.map(function (defNode) {\n        var _a;\n        if (defNode.plugin) {\n            var defPluginNode = defNode;\n            // tslint:disable-next-line:no-any\n            var slatePluginOrList = defPluginNode.plugin.toPlugin\n                ? // tslint:disable-next-line:no-any\n                    defPluginNode.plugin.toPlugin()\n                : defPluginNode.plugin;\n            // the result of plugin.toPlugin might be an array, e.g. the list plugin is an array, because it defines ul, li AND indention-options on the same plugin\n            var firstComponentPlugin = flattenDeep(slatePluginOrList).find(function (plugin) { return plugin.pluginType === 'component' || plugin; });\n            if (firstComponentPlugin &&\n                firstComponentPlugin.pluginType === 'component') {\n                return __assign(__assign({ type: firstComponentPlugin.type }, (_a = defPluginNode.data, (_a !== null && _a !== void 0 ? _a : {}))), { children: defPluginNode.children\n                        ? transformChildren(defPluginNode.children)\n                        : [] });\n            }\n            else {\n                return null;\n            }\n        }\n        else if (typeof defNode === 'string') {\n            return {\n                text: defNode,\n            };\n        }\n    });\n};\nexport default (function (def) { return ({\n    slate: transformChildren(def.children),\n}); });\n//# sourceMappingURL=transformInitialSlateState.js.map"]},"metadata":{},"sourceType":"module"}