{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { v4 } from 'uuid';\nimport { editMode } from '../display';\nimport { generateIds } from '../helpers';\nimport { focusCell } from './core';\nexport var CELL_INSERT_ABOVE = 'CELL_INSERT_ABOVE';\nexport var CELL_INSERT_BELOW = 'CELL_INSERT_BELOW';\nexport var CELL_INSERT_LEFT_OF = 'CELL_INSERT_LEFT_OF';\nexport var CELL_INSERT_RIGHT_OF = 'CELL_INSERT_RIGHT_OF';\nexport var CELL_INSERT_INLINE_LEFT = 'CELL_INSERT_INLINE_LEFT';\nexport var CELL_INSERT_INLINE_RIGHT = 'CELL_INSERT_INLINE_RIGHT';\nexport var CELL_DUPLICATE = 'CELL_DUPLICATE';\n\nvar insert = function (type) {\n  return function (item, _a, level, ids) {\n    var hover = _a.id,\n        inline = _a.inline,\n        hasInlineNeighbour = _a.hasInlineNeighbour;\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (ids === void 0) {\n      ids = null;\n    }\n\n    var l = level;\n\n    switch (type) {\n      case CELL_INSERT_ABOVE:\n      case CELL_INSERT_BELOW:\n        {\n          if ((inline || hasInlineNeighbour) && level < 1) {\n            l = 1;\n          }\n\n          break;\n        }\n\n      case CELL_INSERT_LEFT_OF:\n      case CELL_INSERT_RIGHT_OF:\n        {\n          if ((inline || hasInlineNeighbour) && level < 1) {\n            l = 1;\n          }\n\n          break;\n        }\n\n      default:\n    }\n\n    var insertAction = {\n      type: type,\n      ts: new Date(),\n      item: item,\n      hover: hover,\n      level: l,\n      // FIXME: item handling is a bit confusing,\n      // we now give some of them a name like \"cell\" or \"item\",\n      // but the purpose of the others is unclear\n      ids: ids ? ids : generateIds()\n    };\n    return function (dispatch) {\n      dispatch(insertAction); // FIXME: checking if an item is new or just moved around is a bit awkward\n\n      var isNew = !item.id || item.rows && !item.levels;\n\n      if (isNew) {\n        dispatch(editMode());\n      }\n\n      setTimeout(function () {\n        dispatch(focusCell(insertAction.ids.item)());\n      }, 300);\n    };\n  };\n};\n/**\n * Insert a cell below of the hovering cell.\n */\n\n\nexport var insertCellBelow = insert(CELL_INSERT_BELOW);\n/**\n * Insert a cell above of the hovering cell.\n */\n\nexport var insertCellAbove = insert(CELL_INSERT_ABOVE);\n/**\n * Insert a cell right of the hovering cell.\n */\n\nexport var insertCellRightOf = insert(CELL_INSERT_RIGHT_OF);\n/**\n * Insert a cell left of the hovering cell.\n */\n\nexport var insertCellLeftOf = insert(CELL_INSERT_LEFT_OF);\n/**\n * Insert a cell inside the hovering cell, on the left.\n */\n\nexport var insertCellLeftInline = insert(CELL_INSERT_INLINE_LEFT);\n/**\n * Insert a cell inside the hovering cell, on the right.\n */\n\nexport var insertCellRightInline = insert(CELL_INSERT_INLINE_RIGHT); // set new ids recursivly\n\nvar newIds = function (_a) {\n  var id = _a.id,\n      item = __rest(_a, [\"id\"]);\n\n  return __assign(__assign({}, item), {\n    id: v4(),\n    rows: item.rows ? item.rows.map(function (row) {\n      return __assign(__assign({}, row), {\n        id: v4(),\n        cells: row.cells ? row.cells.map(newIds) : undefined\n      });\n    }) : undefined\n  });\n};\n\nexport var duplicateCell = function (item) {\n  return function (dispatch) {\n    return dispatch(insertCellBelow(newIds(item), item));\n  };\n};\nexport var insertActions = {\n  insertCellRightInline: insertCellRightInline,\n  insertCellLeftInline: insertCellLeftInline,\n  insertCellLeftOf: insertCellLeftOf,\n  insertCellRightOf: insertCellRightOf,\n  insertCellAbove: insertCellAbove,\n  insertCellBelow: insertCellBelow,\n  duplicateCell: duplicateCell,\n  insert: insert\n};","map":{"version":3,"sources":["../../../src/actions/cell/insert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { v4 } from 'uuid';\nimport { editMode } from '../display';\nimport { generateIds } from '../helpers';\nimport { focusCell } from './core';\nexport var CELL_INSERT_ABOVE = 'CELL_INSERT_ABOVE';\nexport var CELL_INSERT_BELOW = 'CELL_INSERT_BELOW';\nexport var CELL_INSERT_LEFT_OF = 'CELL_INSERT_LEFT_OF';\nexport var CELL_INSERT_RIGHT_OF = 'CELL_INSERT_RIGHT_OF';\nexport var CELL_INSERT_INLINE_LEFT = 'CELL_INSERT_INLINE_LEFT';\nexport var CELL_INSERT_INLINE_RIGHT = 'CELL_INSERT_INLINE_RIGHT';\nexport var CELL_DUPLICATE = 'CELL_DUPLICATE';\nvar insert = function (type) { return function (item, _a, level, ids) {\n    var hover = _a.id, inline = _a.inline, hasInlineNeighbour = _a.hasInlineNeighbour;\n    if (level === void 0) { level = 0; }\n    if (ids === void 0) { ids = null; }\n    var l = level;\n    switch (type) {\n        case CELL_INSERT_ABOVE:\n        case CELL_INSERT_BELOW: {\n            if ((inline || hasInlineNeighbour) && level < 1) {\n                l = 1;\n            }\n            break;\n        }\n        case CELL_INSERT_LEFT_OF:\n        case CELL_INSERT_RIGHT_OF: {\n            if ((inline || hasInlineNeighbour) && level < 1) {\n                l = 1;\n            }\n            break;\n        }\n        default:\n    }\n    var insertAction = {\n        type: type,\n        ts: new Date(),\n        item: item,\n        hover: hover,\n        level: l,\n        // FIXME: item handling is a bit confusing,\n        // we now give some of them a name like \"cell\" or \"item\",\n        // but the purpose of the others is unclear\n        ids: ids ? ids : generateIds(),\n    };\n    return function (dispatch) {\n        dispatch(insertAction);\n        // FIXME: checking if an item is new or just moved around is a bit awkward\n        var isNew = !item.id || (item.rows && !item.levels);\n        if (isNew) {\n            dispatch(editMode());\n        }\n        setTimeout(function () {\n            dispatch(focusCell(insertAction.ids.item)());\n        }, 300);\n    };\n}; };\n/**\n * Insert a cell below of the hovering cell.\n */\nexport var insertCellBelow = insert(CELL_INSERT_BELOW);\n/**\n * Insert a cell above of the hovering cell.\n */\nexport var insertCellAbove = insert(CELL_INSERT_ABOVE);\n/**\n * Insert a cell right of the hovering cell.\n */\nexport var insertCellRightOf = insert(CELL_INSERT_RIGHT_OF);\n/**\n * Insert a cell left of the hovering cell.\n */\nexport var insertCellLeftOf = insert(CELL_INSERT_LEFT_OF);\n/**\n * Insert a cell inside the hovering cell, on the left.\n */\nexport var insertCellLeftInline = insert(CELL_INSERT_INLINE_LEFT);\n/**\n * Insert a cell inside the hovering cell, on the right.\n */\nexport var insertCellRightInline = insert(CELL_INSERT_INLINE_RIGHT);\n// set new ids recursivly\nvar newIds = function (_a) {\n    var id = _a.id, item = __rest(_a, [\"id\"]);\n    return __assign(__assign({}, item), { id: v4(), rows: item.rows\n            ? item.rows.map(function (row) { return (__assign(__assign({}, row), { id: v4(), cells: row.cells ? row.cells.map(newIds) : undefined })); })\n            : undefined });\n};\nexport var duplicateCell = function (item) { return function (dispatch) {\n    return dispatch(insertCellBelow(newIds(item), item));\n}; };\nexport var insertActions = {\n    insertCellRightInline: insertCellRightInline,\n    insertCellLeftInline: insertCellLeftInline,\n    insertCellLeftOf: insertCellLeftOf,\n    insertCellRightOf: insertCellRightOf,\n    insertCellAbove: insertCellAbove,\n    insertCellBelow: insertCellBelow,\n    duplicateCell: duplicateCell,\n    insert: insert,\n};\n//# sourceMappingURL=insert.js.map"]},"metadata":{},"sourceType":"module"}