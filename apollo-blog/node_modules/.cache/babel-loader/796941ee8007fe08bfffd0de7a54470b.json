{"ast":null,"code":"/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport * as React from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { bindActionCreators } from 'redux';\nimport { createStructuredSelector } from 'reselect';\nimport { updateCellLayout } from '../../../actions/cell';\nimport { connect } from '../../../reduxConnect';\nimport { isEditMode, isPreviewMode } from '../../../selector/display';\nimport Row from '../../Row';\nimport scollIntoViewWithOffset from '../utils/scollIntoViewWithOffset'; // TODO clean me up #157\n\nvar Layout =\n/** @class */\nfunction (_super) {\n  __extends(Layout, _super);\n\n  function Layout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.onRef = function (ref) {\n      _this.ref = ref;\n    };\n\n    _this.onChange = function (state) {\n      _this.props.updateCellLayout(state);\n    };\n\n    return _this;\n  }\n\n  Layout.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var was = this.props.node.focused;\n    var _a = nextProps.node,\n        is = _a.focused,\n        focusSource = _a.focusSource;\n\n    var editable = nextProps.editable,\n        id = nextProps.id,\n        _b = nextProps.node,\n        _c = _b.layout,\n        _d = _c === void 0 ? {} : _c,\n        _e = _d.plugin,\n        _f = _e === void 0 ? {} : _e,\n        _g = _f.handleFocus,\n        handleFocus = _g === void 0 ? function () {\n      return null;\n    } : _g,\n        _h = _f.handleBlur,\n        handleBlur = _h === void 0 ? function () {\n      return null;\n    } : _h,\n        _j = _f.name,\n        name = _j === void 0 ? 'N/A' : _j,\n        _k = _f.version,\n        version = _k === void 0 ? 'N/A' : _k,\n        _l = _d.state,\n        state = _l === void 0 ? {} : _l,\n        focused = _b.focused,\n        updateCellContent = nextProps.updateCellContent; // FIXME this is really shitty because it will break when the state changes before the blur comes through, see #157\n\n\n    var pass = {\n      editable: editable,\n      id: id,\n      state: state,\n      focused: Boolean(this.props.isEditMode && focused),\n      readOnly: !this.props.isEditMode,\n      onChange: updateCellContent,\n      name: name,\n      version: version,\n      remove: this.props.removeCell\n    }; // Basically we check if the focus state changed and if yes, we execute the callback handler from the plugin, that\n    // can set some side effects.\n\n    if (!was && is) {\n      // We need this because otherwise we lose hotkey focus on elements like spoilers.\n      // This could probably be solved in an easier way by listening to window.document?\n      handleFocus(pass, focusSource, this.ref);\n\n      if (this.ref) {\n        scollIntoViewWithOffset(this.ref, 100);\n      }\n    } else if (was && !is) {\n      handleBlur(pass);\n    }\n  };\n\n  Layout.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        id = _a.id,\n        _b = _a.node,\n        _c = _b.rows,\n        rows = _c === void 0 ? [] : _c,\n        layout = _b.layout,\n        focused = _b.focused,\n        editable = _a.editable,\n        _d = _a.ancestors,\n        ancestors = _d === void 0 ? [] : _d;\n    var plugin = layout.plugin,\n        state = layout.state;\n    var Component = plugin.Component,\n        version = plugin.version,\n        name = plugin.name,\n        text = plugin.text;\n    var _e = this.props,\n        focusCell = _e.focusCell,\n        blurCell = _e.blurCell,\n        removeCell = _e.removeCell;\n    var focusProps;\n\n    if (!this.props.isPreviewMode) {\n      focusProps = {\n        // FIXME this should be MouseEvent\n        onMouseDown: function (e) {\n          if (!focused && e.target.closest('.ory-cell-inner') === findDOMNode(_this.ref)) {\n            focusCell({\n              source: 'onMouseDown'\n            });\n          }\n\n          return true;\n        }\n      };\n    }\n\n    return React.createElement(\"div\", __assign({}, focusProps, {\n      tabIndex: \"-1\",\n      className: \"ory-cell-inner\",\n      ref: this.onRef\n    }), React.createElement(Component, {\n      id: id,\n      state: state,\n      focus: focusCell,\n      blur: blurCell,\n      editable: editable,\n      focused: this.props.isEditMode && focused,\n      name: name,\n      text: text,\n      version: version,\n      readOnly: !this.props.isEditMode,\n      onChange: this.onChange,\n      remove: removeCell\n    }, rows.map(function (r) {\n      return React.createElement(Row, {\n        editable: editable,\n        ancestors: __spread(ancestors, [id]),\n        key: r,\n        id: r\n      });\n    })));\n  };\n\n  return Layout;\n}(React.PureComponent);\n\nvar mapStateToProps = createStructuredSelector({\n  isEditMode: isEditMode,\n  isPreviewMode: isPreviewMode\n});\n\nvar mapDispatchToProps = function (dispatch, _a) {\n  var id = _a.id;\n  return bindActionCreators({\n    updateCellLayout: updateCellLayout(id)\n  }, // tslint:disable-next-line:no-any\n  dispatch);\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Layout);","map":{"version":3,"sources":["../../../../src/components/Cell/Layout/index.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * This file is part of ORY Editor.\n *\n * ORY Editor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * ORY Editor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ORY Editor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @license LGPL-3.0\n * @copyright 2016-2018 Aeneas Rekkas\n * @author Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport * as React from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { bindActionCreators } from 'redux';\nimport { createStructuredSelector } from 'reselect';\nimport { updateCellLayout } from '../../../actions/cell';\nimport { connect } from '../../../reduxConnect';\nimport { isEditMode, isPreviewMode } from '../../../selector/display';\nimport Row from '../../Row';\nimport scollIntoViewWithOffset from '../utils/scollIntoViewWithOffset';\n// TODO clean me up #157\nvar Layout = /** @class */ (function (_super) {\n    __extends(Layout, _super);\n    function Layout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.onRef = function (ref) {\n            _this.ref = ref;\n        };\n        _this.onChange = function (state) {\n            _this.props.updateCellLayout(state);\n        };\n        return _this;\n    }\n    Layout.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n        var was = this.props.node.focused;\n        var _a = nextProps.node, is = _a.focused, focusSource = _a.focusSource;\n        var editable = nextProps.editable, id = nextProps.id, _b = nextProps.node, _c = _b.layout, _d = _c === void 0 ? {} : _c, _e = _d.plugin, _f = _e === void 0 ? {} : _e, _g = _f.handleFocus, handleFocus = _g === void 0 ? function () { return null; } : _g, _h = _f.handleBlur, handleBlur = _h === void 0 ? function () { return null; } : _h, _j = _f.name, name = _j === void 0 ? 'N/A' : _j, _k = _f.version, version = _k === void 0 ? 'N/A' : _k, _l = _d.state, state = _l === void 0 ? {} : _l, focused = _b.focused, updateCellContent = nextProps.updateCellContent;\n        // FIXME this is really shitty because it will break when the state changes before the blur comes through, see #157\n        var pass = {\n            editable: editable,\n            id: id,\n            state: state,\n            focused: Boolean(this.props.isEditMode && focused),\n            readOnly: !this.props.isEditMode,\n            onChange: updateCellContent,\n            name: name,\n            version: version,\n            remove: this.props.removeCell,\n        };\n        // Basically we check if the focus state changed and if yes, we execute the callback handler from the plugin, that\n        // can set some side effects.\n        if (!was && is) {\n            // We need this because otherwise we lose hotkey focus on elements like spoilers.\n            // This could probably be solved in an easier way by listening to window.document?\n            handleFocus(pass, focusSource, this.ref);\n            if (this.ref) {\n                scollIntoViewWithOffset(this.ref, 100);\n            }\n        }\n        else if (was && !is) {\n            handleBlur(pass);\n        }\n    };\n    Layout.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, id = _a.id, _b = _a.node, _c = _b.rows, rows = _c === void 0 ? [] : _c, layout = _b.layout, focused = _b.focused, editable = _a.editable, _d = _a.ancestors, ancestors = _d === void 0 ? [] : _d;\n        var plugin = layout.plugin, state = layout.state;\n        var Component = plugin.Component, version = plugin.version, name = plugin.name, text = plugin.text;\n        var _e = this.props, focusCell = _e.focusCell, blurCell = _e.blurCell, removeCell = _e.removeCell;\n        var focusProps;\n        if (!this.props.isPreviewMode) {\n            focusProps = {\n                // FIXME this should be MouseEvent\n                onMouseDown: function (e) {\n                    if (!focused &&\n                        e.target.closest('.ory-cell-inner') ===\n                            findDOMNode(_this.ref)) {\n                        focusCell({ source: 'onMouseDown' });\n                    }\n                    return true;\n                },\n            };\n        }\n        return (React.createElement(\"div\", __assign({}, focusProps, { tabIndex: \"-1\", className: \"ory-cell-inner\", ref: this.onRef }),\n            React.createElement(Component, { id: id, state: state, focus: focusCell, blur: blurCell, editable: editable, focused: this.props.isEditMode && focused, name: name, text: text, version: version, readOnly: !this.props.isEditMode, onChange: this.onChange, remove: removeCell }, rows.map(function (r) { return (React.createElement(Row, { editable: editable, ancestors: __spread(ancestors, [id]), key: r, id: r })); }))));\n    };\n    return Layout;\n}(React.PureComponent));\nvar mapStateToProps = createStructuredSelector({ isEditMode: isEditMode, isPreviewMode: isPreviewMode });\nvar mapDispatchToProps = function (dispatch, _a) {\n    var id = _a.id;\n    return bindActionCreators({\n        updateCellLayout: updateCellLayout(id),\n    }, \n    // tslint:disable-next-line:no-any\n    dispatch);\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Layout);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}