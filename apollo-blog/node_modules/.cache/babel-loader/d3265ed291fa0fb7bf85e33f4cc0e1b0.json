{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nexport var source = {\n  beginDrag: function (props) {\n    // Begin dragging the cell\n    props.dragCell(props.id);\n    return __assign(__assign({}, props), {\n      // we do not want to pass down the react children or we will risk circular dependencies.\n      children: null,\n      node: __assign(__assign({}, props.node), {\n        rows: props.rawNode().rows\n      })\n    });\n  },\n  endDrag: function (_a, monitor) {\n    var cancelCellDrag = _a.cancelCellDrag,\n        id = _a.id;\n\n    if (monitor.didDrop()) {\n      // If the item drop occurred deeper down the tree, don't do anything\n      return;\n    } // If drag ended but drop did not occur, cancel dragging\n\n\n    cancelCellDrag();\n  }\n};\nexport var collect = function (connect, monitor) {\n  return {\n    connectDragSource: connect.dragSource(),\n    isDragging: monitor.isDragging(),\n    connectDragPreview: connect.dragPreview()\n  };\n};","map":{"version":3,"sources":["../../../../../src/components/Cell/Draggable/helper/dnd.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAGA,OAAO,IAAM,MAAM,GAAG;AACpB,EAAA,SAAS,EAAT,UAAU,KAAV,EAAiC;AAC/B;AACA,IAAA,KAAK,CAAC,QAAN,CAAe,KAAK,CAAC,EAArB;AACA,WAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACK,KADL,CAAA,EACU;AACR;AACA,MAAA,QAAQ,EAAE,IAFF;AAGR,MAAA,IAAI,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACC,KAAK,CAAC,IADP,CAAA,EACW;AACb,QAAA,IAAI,EAAE,KAAK,CAAC,OAAN,GAAgB;AADT,OADX;AAHI,KADV,CAAA;AASD,GAbmB;AAepB,EAAA,OAAO,EAAP,UACE,EADF,EAEE,OAFF,EAE4B;QADxB,cAAA,GAAA,EAAA,CAAA,c;QAAgB,EAAA,GAAA,EAAA,CAAA,E;;AAGlB,QAAI,OAAO,CAAC,OAAR,EAAJ,EAAuB;AACrB;AACA;AACD,KALyB,CAO1B;;;AACA,IAAA,cAAc;AACf;AA1BmB,CAAf;AA6BP,OAAO,IAAM,OAAO,GAAG,UACrB,OADqB,EAErB,OAFqB,EAEK;AACvB,SAAC;AACJ,IAAA,iBAAiB,EAAE,OAAO,CAAC,UAAR,EADf;AAEJ,IAAA,UAAU,EAAE,OAAO,CAAC,UAAR,EAFR;AAGJ,IAAA,kBAAkB,EAAE,OAAO,CAAC,WAAR;AAHhB,GAAD;AAIH,CAPK","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var source = {\n    beginDrag: function (props) {\n        // Begin dragging the cell\n        props.dragCell(props.id);\n        return __assign(__assign({}, props), { \n            // we do not want to pass down the react children or we will risk circular dependencies.\n            children: null, node: __assign(__assign({}, props.node), { rows: props.rawNode().rows }) });\n    },\n    endDrag: function (_a, monitor) {\n        var cancelCellDrag = _a.cancelCellDrag, id = _a.id;\n        if (monitor.didDrop()) {\n            // If the item drop occurred deeper down the tree, don't do anything\n            return;\n        }\n        // If drag ended but drop did not occur, cancel dragging\n        cancelCellDrag();\n    },\n};\nexport var collect = function (connect, monitor) { return ({\n    connectDragSource: connect.dragSource(),\n    isDragging: monitor.isDragging(),\n    connectDragPreview: connect.dragPreview(),\n}); };\n//# sourceMappingURL=dnd.js.map"]},"metadata":{},"sourceType":"module"}