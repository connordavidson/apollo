{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport isHotkey from 'is-hotkey';\nimport React, { useCallback, useEffect, useMemo } from 'react';\nimport { createStructuredSelector } from 'reselect';\nimport { blurAllCells, focusCell, removeCell } from '../../actions/cell';\nimport { redo, undo } from '../../actions/undo';\nimport { connect } from '../../reduxConnect';\nimport { isEditMode } from '../../selector/display';\nimport { editable, editables, node, searchNodeEverywhere } from '../../selector/editable';\nimport { focus } from '../../selector/focus';\n\nvar nextLeaf = function (order, current) {\n  if (order === void 0) {\n    order = [];\n  }\n\n  var last;\n  return order.find(function (c) {\n    if (last === current) {\n      return c.isLeaf;\n    }\n\n    last = c.id;\n    return false;\n  });\n};\n\nvar previousLeaf = function (order, current) {\n  return nextLeaf(__spread(order).reverse(), current);\n};\n\nvar delegateToPlugin = function (event, n, handlerName) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var plugin;\n\n    var _a, _b, _c, _d, _e, _f;\n\n    return __generator(this, function (_g) {\n      switch (_g.label) {\n        case 0:\n          plugin = (_c = (_b = (_a = n) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.plugin, _c !== null && _c !== void 0 ? _c : (_e = (_d = n) === null || _d === void 0 ? void 0 : _d.content) === null || _e === void 0 ? void 0 : _e.plugin);\n          if (!((_f = plugin) === null || _f === void 0 ? void 0 : _f[handlerName])) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , plugin[handlerName](event, n)];\n\n        case 1:\n          _g.sent();\n\n          _g.label = 2;\n\n        case 2:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\n\nvar Decorator = function (props) {\n  var delegateToFoundPlugin = useCallback(function (event, nodeId, handlerName, defaultHandler) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var cellNode, e_1;\n\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            cellNode = (_b = (_a = props.searchNodeEverywhere(nodeId)) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.node;\n            _c.label = 1;\n\n          case 1:\n            _c.trys.push([1, 5,, 6]);\n\n            if (!cellNode) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , delegateToPlugin(event, cellNode, handlerName)];\n\n          case 2:\n            _c.sent();\n\n            _c.label = 3;\n\n          case 3:\n            // if the plugin handler resolve or there is no, they do not handle it, so do the default\n            return [4\n            /*yield*/\n            , defaultHandler(event, cellNode)];\n\n          case 4:\n            // if the plugin handler resolve or there is no, they do not handle it, so do the default\n            _c.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            e_1 = _c.sent();\n\n            if (e_1) {\n              // tslint:disable-next-line:no-console\n              console.error(e_1);\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, []);\n  var handlers = useMemo(function () {\n    return [{\n      hotkeys: ['ctrl+z', 'command+z'],\n      handler: function () {\n        props.undo(props.id);\n      }\n    }, {\n      hotkeys: ['ctrl+shift+z', 'ctrl+y', 'command+shift+z', 'command+y'],\n      handler: function () {\n        props.redo(props.id);\n      }\n    }, {\n      hotkeys: ['alt+del', 'alt+backspace'],\n      handler: function (event) {\n        delegateToFoundPlugin(event, props.focus, 'handleRemoveHotKey', function () {\n          return props.removeCell(props.focus);\n        });\n      }\n    }, {\n      hotkeys: ['alt+down', 'alt+right'],\n      handler: function (event) {\n        delegateToFoundPlugin(event, props.focus, 'handleFocusNextHotKey', function () {\n          var found = nextLeaf(props.editable.cellOrder, props.focus);\n\n          if (found) {\n            props.blurAllCells();\n            props.focusCell(found.id);\n          }\n        });\n      }\n    }, {\n      hotkeys: ['alt+up', 'alt+left'],\n      handler: function (event) {\n        delegateToFoundPlugin(event, props.focus, 'handleFocusPreviousHotKey', function () {\n          var found = previousLeaf(props.editable.cellOrder, props.focus);\n\n          if (found) {\n            props.blurAllCells();\n            props.focusCell(found.id);\n          }\n        });\n      }\n    }];\n  }, [props.id, props.focus, props.editable]);\n  useEffect(function () {\n    // in editmode we only allow hotkeys if a cell is focused.\n    // this is because if we have multiple editors on the same page, we don't want to interfer with others\n    // and also to make it more explicit\n    // The BlurGate currently guarantees that only one editor ever has a focused cell, so we already know on which one we can apply hotkeys\n    // If the editor is in another mode, all hot keys are allowed (which is useful for undo/redo, e.g. when resizing)\n    // because the BlurGate also guarantees that only one editor will be in another mode then editMode\n    // This is not totally clean, but it works very well.\n    if (props.isEditMode && !props.focus) {\n      return;\n    }\n\n    var keyHandler = function (event) {\n      var _a;\n\n      var matchingHandler = handlers.find(function (handler) {\n        return handler.hotkeys.some(function (hotkey) {\n          return isHotkey(hotkey, event);\n        });\n      });\n      (_a = matchingHandler) === null || _a === void 0 ? void 0 : _a.handler(event);\n    };\n\n    document.addEventListener('keydown', keyHandler);\n    return function () {\n      document.removeEventListener('keydown', keyHandler);\n    };\n  }, [handlers, props.focus, props.isEditMode]);\n  return React.createElement(React.Fragment, null, props.children);\n};\n/** FIXME: we should start using hooks for redux. this would drastically simplify this whole thing */\n\n\nvar mapStateToProps = createStructuredSelector({\n  isEditMode: isEditMode,\n  focus: focus,\n  // tslint:disable-next-line:no-any\n  node: function (state) {\n    return function (id, _editable) {\n      return node(state, {\n        id: id,\n        editable: _editable\n      });\n    };\n  },\n  searchNodeEverywhere: function (state) {\n    return function (id) {\n      return searchNodeEverywhere(state, id);\n    };\n  },\n  // tslint:disable-next-line:no-any\n  editable: function (state, props) {\n    return editable(state, {\n      id: props.id\n    });\n  },\n  editables: editables\n});\nvar mapDispatchToProps = {\n  undo: undo,\n  redo: redo,\n  removeCell: removeCell,\n  focusCell: function (id) {\n    return focusCell(id)();\n  },\n  blurAllCells: blurAllCells\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Decorator);","map":{"version":3,"sources":["../../../src/components/HotKey/Decorator.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport isHotkey from 'is-hotkey';\nimport React, { useCallback, useEffect, useMemo } from 'react';\nimport { createStructuredSelector } from 'reselect';\nimport { blurAllCells, focusCell, removeCell } from '../../actions/cell';\nimport { redo, undo } from '../../actions/undo';\nimport { connect } from '../../reduxConnect';\nimport { isEditMode } from '../../selector/display';\nimport { editable, editables, node, searchNodeEverywhere } from '../../selector/editable';\nimport { focus } from '../../selector/focus';\nvar nextLeaf = function (order, current) {\n    if (order === void 0) { order = []; }\n    var last;\n    return order.find(function (c) {\n        if (last === current) {\n            return c.isLeaf;\n        }\n        last = c.id;\n        return false;\n    });\n};\nvar previousLeaf = function (order, current) {\n    return nextLeaf(__spread(order).reverse(), current);\n};\nvar delegateToPlugin = function (event, n, handlerName) { return __awaiter(void 0, void 0, void 0, function () {\n    var plugin;\n    var _a, _b, _c, _d, _e, _f;\n    return __generator(this, function (_g) {\n        switch (_g.label) {\n            case 0:\n                plugin = (_c = (_b = (_a = n) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.plugin, (_c !== null && _c !== void 0 ? _c : (_e = (_d = n) === null || _d === void 0 ? void 0 : _d.content) === null || _e === void 0 ? void 0 : _e.plugin));\n                if (!((_f = plugin) === null || _f === void 0 ? void 0 : _f[handlerName])) return [3 /*break*/, 2];\n                return [4 /*yield*/, plugin[handlerName](event, n)];\n            case 1:\n                _g.sent();\n                _g.label = 2;\n            case 2: return [2 /*return*/];\n        }\n    });\n}); };\nvar Decorator = function (props) {\n    var delegateToFoundPlugin = useCallback(function (event, nodeId, handlerName, defaultHandler) { return __awaiter(void 0, void 0, void 0, function () {\n        var cellNode, e_1;\n        var _a, _b;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    cellNode = (_b = (_a = props.searchNodeEverywhere(nodeId)) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.node;\n                    _c.label = 1;\n                case 1:\n                    _c.trys.push([1, 5, , 6]);\n                    if (!cellNode) return [3 /*break*/, 3];\n                    return [4 /*yield*/, delegateToPlugin(event, cellNode, handlerName)];\n                case 2:\n                    _c.sent();\n                    _c.label = 3;\n                case 3: \n                // if the plugin handler resolve or there is no, they do not handle it, so do the default\n                return [4 /*yield*/, defaultHandler(event, cellNode)];\n                case 4:\n                    // if the plugin handler resolve or there is no, they do not handle it, so do the default\n                    _c.sent();\n                    return [3 /*break*/, 6];\n                case 5:\n                    e_1 = _c.sent();\n                    if (e_1) {\n                        // tslint:disable-next-line:no-console\n                        console.error(e_1);\n                    }\n                    return [3 /*break*/, 6];\n                case 6: return [2 /*return*/];\n            }\n        });\n    }); }, []);\n    var handlers = useMemo(function () { return [\n        {\n            hotkeys: ['ctrl+z', 'command+z'],\n            handler: function () {\n                props.undo(props.id);\n            },\n        },\n        {\n            hotkeys: ['ctrl+shift+z', 'ctrl+y', 'command+shift+z', 'command+y'],\n            handler: function () {\n                props.redo(props.id);\n            },\n        },\n        {\n            hotkeys: ['alt+del', 'alt+backspace'],\n            handler: function (event) {\n                delegateToFoundPlugin(event, props.focus, 'handleRemoveHotKey', function () {\n                    return props.removeCell(props.focus);\n                });\n            },\n        },\n        {\n            hotkeys: ['alt+down', 'alt+right'],\n            handler: function (event) {\n                delegateToFoundPlugin(event, props.focus, 'handleFocusNextHotKey', function () {\n                    var found = nextLeaf(props.editable.cellOrder, props.focus);\n                    if (found) {\n                        props.blurAllCells();\n                        props.focusCell(found.id);\n                    }\n                });\n            },\n        },\n        {\n            hotkeys: ['alt+up', 'alt+left'],\n            handler: function (event) {\n                delegateToFoundPlugin(event, props.focus, 'handleFocusPreviousHotKey', function () {\n                    var found = previousLeaf(props.editable.cellOrder, props.focus);\n                    if (found) {\n                        props.blurAllCells();\n                        props.focusCell(found.id);\n                    }\n                });\n            },\n        },\n    ]; }, [props.id, props.focus, props.editable]);\n    useEffect(function () {\n        // in editmode we only allow hotkeys if a cell is focused.\n        // this is because if we have multiple editors on the same page, we don't want to interfer with others\n        // and also to make it more explicit\n        // The BlurGate currently guarantees that only one editor ever has a focused cell, so we already know on which one we can apply hotkeys\n        // If the editor is in another mode, all hot keys are allowed (which is useful for undo/redo, e.g. when resizing)\n        // because the BlurGate also guarantees that only one editor will be in another mode then editMode\n        // This is not totally clean, but it works very well.\n        if (props.isEditMode && !props.focus) {\n            return;\n        }\n        var keyHandler = function (event) {\n            var _a;\n            var matchingHandler = handlers.find(function (handler) {\n                return handler.hotkeys.some(function (hotkey) { return isHotkey(hotkey, event); });\n            });\n            (_a = matchingHandler) === null || _a === void 0 ? void 0 : _a.handler(event);\n        };\n        document.addEventListener('keydown', keyHandler);\n        return function () {\n            document.removeEventListener('keydown', keyHandler);\n        };\n    }, [handlers, props.focus, props.isEditMode]);\n    return React.createElement(React.Fragment, null, props.children);\n};\n/** FIXME: we should start using hooks for redux. this would drastically simplify this whole thing */\nvar mapStateToProps = createStructuredSelector({\n    isEditMode: isEditMode,\n    focus: focus,\n    // tslint:disable-next-line:no-any\n    node: function (state) { return function (id, _editable) {\n        return node(state, { id: id, editable: _editable });\n    }; },\n    searchNodeEverywhere: function (state) { return function (id) {\n        return searchNodeEverywhere(state, id);\n    }; },\n    // tslint:disable-next-line:no-any\n    editable: function (state, props) { return editable(state, { id: props.id }); },\n    editables: editables,\n});\nvar mapDispatchToProps = {\n    undo: undo,\n    redo: redo,\n    removeCell: removeCell,\n    focusCell: function (id) { return focusCell(id)(); },\n    blurAllCells: blurAllCells,\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Decorator);\n//# sourceMappingURL=Decorator.js.map"]},"metadata":{},"sourceType":"module"}