{"ast":null,"code":"import throttle from 'lodash.throttle';\nimport { createNativeCellReplacement, isNativeHTMLElementDrag } from '../../../../helper/nativeDragHelpers';\nimport { delay } from '../../../../helper/throttle';\nimport { computeAndDispatchHover, computeAndDispatchInsert } from '../../../../service/hover/input';\nimport logger from '../../../../service/logger';\nvar last = {\n  hover: '',\n  drag: ''\n};\n\nvar clear = function (hover, drag) {\n  if (hover.id === last.hover && drag === last.drag) {\n    return;\n  }\n\n  last = {\n    hover: hover.id,\n    drag: drag\n  };\n  hover.clearHover();\n};\n\nexport var target = {\n  hover: throttle(function (hover, monitor, component) {\n    var _a, _b, _c, _d, _e; // tslint:disable-next-line:no-any\n\n\n    var drag = monitor.getItem();\n\n    if (!drag) {\n      // item undefined, happens when throttle triggers after drop\n      return;\n    }\n\n    if (isNativeHTMLElementDrag(monitor)) {\n      drag = createNativeCellReplacement();\n    }\n\n    if (drag.id === hover.id) {\n      // If hovering over itself, do nothing\n      clear(hover, drag.id);\n      return;\n    } else if (!monitor.isOver({\n      shallow: true\n    })) {\n      // If hovering over ancestor cell, do nothing (we are going to propagate later in the tree anyways)\n      return;\n    } else if (hover.ancestors.indexOf(drag.id) > -1) {\n      // If hovering over a child of itself\n      clear(hover, drag.id);\n      return;\n    } else if (!hover.id) {\n      // If hovering over something that isn't a cell or hasn't an id, do nothing. Should be an edge case\n      logger.warn('Canceled cell drop, no id given.', hover, drag);\n      return;\n    }\n\n    last = {\n      hover: hover.id,\n      drag: drag.id\n    };\n    var allowInlineNeighbours = (_e = (_d = (_c = (_b = (_a = hover) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.plugin) === null || _d === void 0 ? void 0 : _d.allowInlineNeighbours, _e !== null && _e !== void 0 ? _e : false);\n    computeAndDispatchHover(hover, drag, monitor, component, \"10x10\" + (allowInlineNeighbours ? '' : '-no-inline'));\n  }, delay, {\n    leading: false\n  }),\n  canDrop: function (_a, monitor) {\n    var id = _a.id,\n        ancestors = _a.ancestors;\n    var item = monitor.getItem();\n    return item.id !== id && ancestors.indexOf(item.id) === -1;\n  },\n  // tslint:disable-next-line:no-any\n  drop: function (hover, monitor, component) {\n    var _a, _b, _c, _d, _e;\n\n    var drag = monitor.getItem();\n\n    if (isNativeHTMLElementDrag(monitor)) {\n      var plugins = component.props.config.plugins;\n      drag = plugins.createNativePlugin(hover, monitor, component);\n    }\n\n    if (monitor.didDrop() || !monitor.isOver({\n      shallow: true\n    })) {\n      // If the item drop occurred deeper down the tree, don't do anything\n      return;\n    } else if (drag.id === hover.id) {\n      // If the item being dropped on itself do nothing\n      hover.cancelCellDrag();\n      return;\n    } else if (hover.ancestors.indexOf(drag.id) > -1) {\n      // If hovering over a child of itself, don't propagate further\n      hover.cancelCellDrag();\n      return;\n    }\n\n    last = {\n      hover: hover.id,\n      drag: drag.id\n    };\n    var allowInlineNeighbours = (_e = (_d = (_c = (_b = (_a = hover) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.plugin) === null || _d === void 0 ? void 0 : _d.allowInlineNeighbours, _e !== null && _e !== void 0 ? _e : false);\n    computeAndDispatchInsert(hover, drag, monitor, component, \"10x10\" + (allowInlineNeighbours ? '' : '-no-inline'));\n  }\n};\nexport var connect = function (connectInner, monitor) {\n  return {\n    connectDropTarget: connectInner.dropTarget(),\n    isOver: monitor.isOver(),\n    isOverCurrent: monitor.isOver({\n      shallow: true\n    })\n  };\n};","map":{"version":3,"sources":["../../../../../src/components/Cell/Droppable/helper/dnd.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import throttle from 'lodash.throttle';\nimport { createNativeCellReplacement, isNativeHTMLElementDrag } from '../../../../helper/nativeDragHelpers';\nimport { delay } from '../../../../helper/throttle';\nimport { computeAndDispatchHover, computeAndDispatchInsert } from '../../../../service/hover/input';\nimport logger from '../../../../service/logger';\nvar last = { hover: '', drag: '' };\nvar clear = function (hover, drag) {\n    if (hover.id === last.hover && drag === last.drag) {\n        return;\n    }\n    last = { hover: hover.id, drag: drag };\n    hover.clearHover();\n};\nexport var target = {\n    hover: throttle(function (hover, monitor, component) {\n        var _a, _b, _c, _d, _e;\n        // tslint:disable-next-line:no-any\n        var drag = monitor.getItem();\n        if (!drag) {\n            // item undefined, happens when throttle triggers after drop\n            return;\n        }\n        if (isNativeHTMLElementDrag(monitor)) {\n            drag = createNativeCellReplacement();\n        }\n        if (drag.id === hover.id) {\n            // If hovering over itself, do nothing\n            clear(hover, drag.id);\n            return;\n        }\n        else if (!monitor.isOver({ shallow: true })) {\n            // If hovering over ancestor cell, do nothing (we are going to propagate later in the tree anyways)\n            return;\n        }\n        else if (hover.ancestors.indexOf(drag.id) > -1) {\n            // If hovering over a child of itself\n            clear(hover, drag.id);\n            return;\n        }\n        else if (!hover.id) {\n            // If hovering over something that isn't a cell or hasn't an id, do nothing. Should be an edge case\n            logger.warn('Canceled cell drop, no id given.', hover, drag);\n            return;\n        }\n        last = { hover: hover.id, drag: drag.id };\n        var allowInlineNeighbours = (_e = (_d = (_c = (_b = (_a = hover) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.plugin) === null || _d === void 0 ? void 0 : _d.allowInlineNeighbours, (_e !== null && _e !== void 0 ? _e : false));\n        computeAndDispatchHover(hover, drag, monitor, component, \"10x10\" + (allowInlineNeighbours ? '' : '-no-inline'));\n    }, delay, { leading: false }),\n    canDrop: function (_a, monitor) {\n        var id = _a.id, ancestors = _a.ancestors;\n        var item = monitor.getItem();\n        return item.id !== id && ancestors.indexOf(item.id) === -1;\n    },\n    // tslint:disable-next-line:no-any\n    drop: function (hover, monitor, component) {\n        var _a, _b, _c, _d, _e;\n        var drag = monitor.getItem();\n        if (isNativeHTMLElementDrag(monitor)) {\n            var plugins = component.props.config.plugins;\n            drag = plugins.createNativePlugin(hover, monitor, component);\n        }\n        if (monitor.didDrop() || !monitor.isOver({ shallow: true })) {\n            // If the item drop occurred deeper down the tree, don't do anything\n            return;\n        }\n        else if (drag.id === hover.id) {\n            // If the item being dropped on itself do nothing\n            hover.cancelCellDrag();\n            return;\n        }\n        else if (hover.ancestors.indexOf(drag.id) > -1) {\n            // If hovering over a child of itself, don't propagate further\n            hover.cancelCellDrag();\n            return;\n        }\n        last = { hover: hover.id, drag: drag.id };\n        var allowInlineNeighbours = (_e = (_d = (_c = (_b = (_a = hover) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.plugin) === null || _d === void 0 ? void 0 : _d.allowInlineNeighbours, (_e !== null && _e !== void 0 ? _e : false));\n        computeAndDispatchInsert(hover, drag, monitor, component, \"10x10\" + (allowInlineNeighbours ? '' : '-no-inline'));\n    },\n};\nexport var connect = function (connectInner, monitor) { return ({\n    connectDropTarget: connectInner.dropTarget(),\n    isOver: monitor.isOver(),\n    isOverCurrent: monitor.isOver({ shallow: true }),\n}); };\n//# sourceMappingURL=dnd.js.map"]},"metadata":{},"sourceType":"module"}